<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Learning Assistant</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #333; margin-bottom: 10px; text-align: center; }
        .mode-selector {
            display: flex; gap: 10px; margin-bottom: 30px;
            background: #f0f0f0; padding: 5px; border-radius: 10px;
        }
        .mode-btn {
            flex: 1; padding: 12px; border: none; border-radius: 8px;
            font-size: 14px; font-weight: bold; cursor: pointer;
            background: transparent; transition: all 0.3s;
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .mode-content { display: none; }
        .mode-content.active { display: block; }
        .input-group { margin-bottom: 20px; }
        textarea {
            width: 100%; padding: 15px; border: 2px solid #ddd;
            border-radius: 10px; font-size: 16px; resize: vertical;
            min-height: 100px; font-family: inherit;
        }
        textarea:focus { outline: none; border-color: #667eea; }
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            flex: 1; padding: 15px; border: none; border-radius: 10px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn-secondary { background: #f0f0f0; color: #333; }
        .btn-secondary:hover { background: #e0e0e0; }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(17, 153, 142, 0.4); }
        .btn-listen { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; }
        .btn-listen:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4); }
        .btn-danger { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; }
        .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4); }
        button:disabled { opacity: 0.6; cursor: not-allowed; transform: none !important; }
        .result {
            background: #f8f9fa; border-radius: 10px; padding: 20px;
            margin-top: 20px; white-space: pre-wrap; line-height: 1.6; display: none;
        }
        .result.show { display: block; }
        .loading { text-align: center; color: #667eea; font-weight: bold; }
        .error { background: #fee; color: #c33; padding: 15px; border-radius: 10px; margin-top: 20px; display: none; }
        .error.show { display: block; }
        .recording-indicator {
            display: none; text-align: center; padding: 10px; background: #ffebee;
            border-radius: 8px; margin-bottom: 15px; color: #c62828;
            font-weight: bold; animation: pulse 1.5s infinite;
        }
        .recording-indicator.active { display: block; }
        .listening-indicator {
            display: none; text-align: center; padding: 10px; background: #e3f2fd;
            border-radius: 8px; margin-bottom: 15px; color: #1976d2;
            font-weight: bold; animation: pulse 1.5s infinite;
        }
        .listening-indicator.active { display: block; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .practice-guide {
            background: #fff9e6; border-left: 4px solid #ffc107;
            padding: 15px; margin-bottom: 20px; border-radius: 5px; font-size: 14px;
        }
        .practice-guide h3 { color: #f57c00; margin-bottom: 10px; font-size: 16px; }
        .practice-guide ol { margin-left: 20px; line-height: 1.8; }
        .practice-guide strong { color: #e65100; }
        .feedback-container { background: white; border-radius: 10px; padding: 20px; margin-top: 20px; }
        .accuracy-score {
            text-align: center; padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border-radius: 10px; margin-bottom: 20px;
        }
        .accuracy-score h2 { font-size: 48px; margin: 0; }
        .accuracy-score p { margin: 5px 0 0 0; font-size: 18px; }
        .word-analysis { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        .word-box {
            padding: 10px 15px; border-radius: 8px;
            font-weight: bold; font-size: 16px; transition: all 0.3s;
        }
        .word-correct { background: #d4edda; color: #155724; border: 2px solid #28a745; }
        .word-incorrect { background: #f8d7da; color: #721c24; border: 2px solid #dc3545; }
        .word-missing { background: #fff3cd; color: #856404; border: 2px solid #ffc107; }
        .text-display {
            background: #fff; border: 2px solid #ddd; border-radius: 10px;
            padding: 20px; margin: 20px 0; line-height: 1.8;
            font-size: 16px; max-height: 400px; overflow-y: auto;
        }
        .word-highlight {
            background: #fff9c4; padding: 2px 4px; border-radius: 3px;
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        .word-highlight:hover { background: #ffeb3b; transform: scale(1.05); }
        .tooltip {
            position: fixed; background: #333; color: white;
            padding: 12px 16px; border-radius: 8px; font-size: 14px;
            max-width: 300px; z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none; white-space: pre-wrap; line-height: 1.5;
        }
        .tooltip.show { display: block; }
        .info-box {
            background: #e3f2fd; border-left: 4px solid #2196f3;
            padding: 15px; margin: 15px 0; border-radius: 5px; font-size: 14px;
        }
        .timer { text-align: center; font-size: 24px; font-weight: bold; color: #c62828; padding: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö AI Learning Assistant</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="pronunciation">üó£Ô∏è Pronunciation</button>
            <button class="mode-btn" data-mode="reading">üìñ Reading Comprehension</button>
        </div>

        <div class="mode-content active" id="pronunciation-mode">
            <div class="practice-guide">
                <h3>üìù Practice Steps:</h3>
                <ol>
                    <li><strong>Listen to Model</strong> - Dengar pronunciation yang benar</li>
                    <li><strong>Record Your Voice</strong> - Baca text dan rekam sampai selesai</li>
                    <li><strong>Stop Recording</strong> - Klik stop setelah selesai</li>
                    <li><strong>Check Pronunciation</strong> - Dapatkan feedback AI</li>
                </ol>
            </div>

            <div class="listening-indicator" id="listeningIndicator">
                üîä Playing model audio... Listen carefully!
            </div>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="timer" id="recordingTimer">00:00</div>
                üî¥ Recording... Click "Stop Recording" when done
            </div>
            
            <div class="input-group">
                <textarea id="phraseInput" placeholder="Type a phrase to practice pronunciation...">Hello, how are you today? I am learning English pronunciation.</textarea>
            </div>
            
            <div class="btn-group">
                <button class="btn-listen" id="listenBtn">üîä Listen to Model</button>
                <button class="btn-success" id="recordBtn">üé§ Start Recording</button>
                <button class="btn-danger" id="stopBtn" style="display:none;">‚èπÔ∏è Stop Recording</button>
            </div>

            <div class="btn-group">
                <button class="btn-primary" id="checkBtn">‚úÖ Check Pronunciation</button>
            </div>
            
            <div class="result" id="pronunciationResult"></div>
            <div class="error" id="pronunciationError"></div>
        </div>

        <div class="mode-content" id="reading-mode">
            <div class="info-box">
                üí° <strong>Cara Pakai:</strong> Paste teks bahasa Inggris, klik kata yang sulit untuk terjemahan, atau generate summary!
            </div>
            
            <div class="input-group">
                <textarea id="readingInput" placeholder="Paste your English text here..." rows="6">The Amazon rainforest is the largest tropical rainforest in the world. It covers much of northwestern Brazil and extends into Colombia, Peru and other South American countries. Scientists believe that millions of species still remain undiscovered in the Amazon.</textarea>
            </div>
            
            <div class="btn-group">
                <button class="btn-primary" id="analyzeBtn">üîç Analyze Text</button>
                <button class="btn-success" id="summaryBtn" style="display:none;">üìù Generate Summary</button>
            </div>
            
            <div class="text-display" id="textDisplay" style="display:none;"></div>
            <div class="result" id="readingResult"></div>
            <div class="error" id="readingError"></div>
        </div>

        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        const modeBtns = document.querySelectorAll('.mode-btn');
        const modeContents = document.querySelectorAll('.mode-content');
        
        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                modeContents.forEach(content => content.classList.remove('active'));
                document.getElementById(mode + '-mode').classList.add('active');
            });
        });

        let mediaRecorder, audioChunks = [], recordedAudioBlob, isListening = false;
        let recordingStartTime, timerInterval;
        
        const phraseInput = document.getElementById('phraseInput');
        const checkBtn = document.getElementById('checkBtn');
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const listenBtn = document.getElementById('listenBtn');
        const pronunciationResult = document.getElementById('pronunciationResult');
        const pronunciationError = document.getElementById('pronunciationError');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const listeningIndicator = document.getElementById('listeningIndicator');
        const recordingTimer = document.getElementById('recordingTimer');

        listenBtn.addEventListener('click', listenToModel);
        recordBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        checkBtn.addEventListener('click', checkPronunciation);

        function listenToModel() {
            const phrase = phraseInput.value.trim();
            if (!phrase) { showPronunciationError('Please enter a phrase first!'); return; }
            if (isListening) {
                window.speechSynthesis.cancel();
                isListening = false;
                listenBtn.textContent = 'üîä Listen to Model';
                listenBtn.className = 'btn-listen';
                listeningIndicator.classList.remove('active');
                return;
            }
            isListening = true;
            listenBtn.textContent = '‚èπÔ∏è Stop Audio';
            listenBtn.className = 'btn-secondary';
            listeningIndicator.classList.add('active');
            pronunciationResult.classList.remove('show');
            pronunciationError.classList.remove('show');
            const utterance = new SpeechSynthesisUtterance(phrase);
            utterance.lang = 'en-US';
            utterance.rate = 0.8;
            utterance.onend = () => {
                isListening = false;
                listenBtn.textContent = 'üîä Listen to Model';
                listenBtn.className = 'btn-listen';
                listeningIndicator.classList.remove('active');
            };
            window.speechSynthesis.speak(utterance);
        }

        async function startRecording() {
            const phrase = phraseInput.value.trim();
            if (!phrase) { showPronunciationError('Please enter a phrase first!'); return; }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = (event) => { audioChunks.push(event.data); };
                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    stream.getTracks().forEach(track => track.stop());
                };
                mediaRecorder.start();
                recordBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                recordingIndicator.classList.add('active');
                pronunciationResult.classList.remove('show');
                pronunciationError.classList.remove('show');
                recordingStartTime = Date.now();
                timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const secs = (elapsed % 60).toString().padStart(2, '0');
                    recordingTimer.textContent = mins + ':' + secs;
                }, 1000);
            } catch (error) {
                showPronunciationError('Could not access microphone: ' + error.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                clearInterval(timerInterval);
                recordBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                recordingIndicator.classList.remove('active');
            }
        }

        async function checkPronunciation() {
            const phrase = phraseInput.value.trim();
            if (!phrase) { showPronunciationError('Please enter a phrase'); return; }
            if (!recordedAudioBlob) { showPronunciationError('Please record your voice first!'); return; }

            pronunciationResult.classList.remove('show');
            pronunciationError.classList.remove('show');
            checkBtn.disabled = true;
            recordBtn.disabled = true;
            listenBtn.disabled = true;
            pronunciationResult.innerHTML = '<div class="loading">ü§î Analyzing pronunciation...</div>';
            pronunciationResult.classList.add('show');

            try {
                const transcribedText = await transcribeAudio();
                const analysis = analyzePronunciation(phrase, transcribedText);
                displayFeedback(phrase, transcribedText, analysis);
            } catch (err) {
                pronunciationResult.classList.remove('show');
                showPronunciationError(err.message);
            } finally {
                checkBtn.disabled = false;
                recordBtn.disabled = false;
                listenBtn.disabled = false;
            }
            function analyzePronunciation(expected, actual) {
            const expectedWords = expected.toLowerCase().replace(/[.,!?]/g, '').split(/\s+/);
            const actualWords = actual.toLowerCase().replace(/[.,!?]/g, '').split(/\s+/);
            
            const analysis = { correct: 0, incorrect: 0, missing: 0, words: [], totalScore: 0 };

            expectedWords.forEach((word, index) => {
                const actualWord = actualWords[index];
                let status = 'missing';
                let score = 0;
                
                if (actualWord) {
                    const distance = levenshteinDistance(actualWord, word);
                    const maxLen = Math.max(word.length, actualWord.length);
                    const similarity = ((maxLen - distance) / maxLen) * 100;
                    
                    // Lebih strict: hanya exact match atau sangat mirip (95%+) yang dianggap correct
                    if (actualWord === word) {
                        status = 'correct';
                        score = 100;
                        analysis.correct++;
                    } else if (similarity >= 95 && distance === 1) {
                        status = 'correct';
                        score = 95;
                        analysis.correct++;
                    } else if (similarity >= 70) {
                        status = 'incorrect';
                        score = similarity;
                        analysis.incorrect++;
                    } else {
                        status = 'incorrect';
                        score = Math.max(0, similarity);
                        analysis.incorrect++;
                    }
                } else {
                    analysis.missing++;
                    score = 0;
                }
                
                analysis.totalScore += score;
                analysis.words.push({ 
                    expected: word, 
                    actual: actualWord || '', 
                    status: status,
                    score: Math.round(score)
                });
            });

            // Calculate realistic accuracy based on individual word scores
            analysis.accuracy = Math.round(analysis.totalScore / expectedWords.length);
            
            // Penalty for missing or extra words
            if (actualWords.length < expectedWords.length) {
                const missingPenalty = ((expectedWords.length - actualWords.length) / expectedWords.length) * 20;
                analysis.accuracy = Math.max(0, analysis.accuracy - Math.round(missingPenalty));
            }
            
            return analysis;
        }
        }

        async function transcribeAudio() {
            return new Promise((resolve) => {
                const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.lang = 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;

                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                const audio = new Audio(audioUrl);

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    resolve(transcript);
                };

                recognition.onerror = () => { resolve(phraseInput.value.trim()); };
                recognition.start();
                audio.play();
                setTimeout(() => { recognition.stop(); resolve(phraseInput.value.trim()); }, 10000);
            });
        }

       
        }

        function levenshteinDistance(a, b) {
            const matrix = [];
            for (let i = 0; i <= b.length; i++) matrix[i] = [i];
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function displayFeedback(expected, actual, analysis) {
            const scoreColor = analysis.accuracy >= 80 ? '#28a745' : analysis.accuracy >= 60 ? '#ffc107' : '#dc3545';
            let html = '<div class="feedback-container">';
            html += `<div class="accuracy-score" style="background: ${scoreColor};"><h2>${analysis.accuracy}%</h2><p>Pronunciation Accuracy</p></div>`;
            html += '<h3 style="margin-bottom: 15px;">üìä Word-by-Word Analysis:</h3><div class="word-analysis">';
            
            analysis.words.forEach(word => {
                let className = 'word-box ', statusIcon = '';
                if (word.status === 'correct') {
                    className += 'word-correct'; statusIcon = ' ‚úì';
                } else if (word.status === 'incorrect') {
                    className += 'word-incorrect'; statusIcon = ' ‚úó';
                } else {
                    className += 'word-missing'; statusIcon = ' ?';
                }
                html += `<div class="${className}">${word.expected}${statusIcon}</div>`;
            });
            
            html += '</div>';
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;
            html += `<p><strong>Expected:</strong> ${expected}</p><p><strong>You said:</strong> ${actual}</p>`;
            html += `<p style="margin-top: 10px;"><span style="color: #28a745;">‚úì Correct: ${analysis.correct}</span> | `;
            html += `<span style="color: #dc3545;">‚úó Incorrect: ${analysis.incorrect}</span> | `;
            html += `<span style="color: #ffc107;">? Missing: ${analysis.missing}</span></p></div></div>`;
            
            pronunciationResult.innerHTML = html;
        }

        function showPronunciationError(message) {
            pronunciationError.textContent = '‚ùå ' + message;
            pronunciationError.classList.add('show');
        }

        // READING COMPREHENSION - UPDATED TO USE NETLIFY FUNCTION
        const readingInput = document.getElementById('readingInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const summaryBtn = document.getElementById('summaryBtn');
        const textDisplay = document.getElementById('textDisplay');
        const readingResult = document.getElementById('readingResult');
        const readingError = document.getElementById('readingError');
        const tooltip = document.getElementById('tooltip');

        let currentText = '';
        analyzeBtn.addEventListener('click', analyzeText);
        summaryBtn.addEventListener('click', generateSummary);

        function analyzeText() {
            currentText = readingInput.value.trim();
            if (!currentText) { showReadingError('Please enter text'); return; }

            readingError.classList.remove('show');
            readingResult.classList.remove('show');
            
            const words = currentText.match(/\b[a-zA-Z]+\b/g) || [];
            const difficultWords = [...new Set(words.filter(word => word.length >= 8))];
            
            let highlightedText = currentText;
            difficultWords.forEach(word => {
                const regex = new RegExp(`\\b(${word})\\b`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="word-highlight" data-word="$1">$1</span>');
            });
            
            textDisplay.innerHTML = highlightedText;
            textDisplay.style.display = 'block';
            summaryBtn.style.display = 'block';
            
            document.querySelectorAll('.word-highlight').forEach(span => {
                span.addEventListener('click', handleWordClick);
            });
        }

        async function handleWordClick(e) {
            const word = e.target.dataset.word;
            const rect = e.target.getBoundingClientRect();
            
            tooltip.innerHTML = '<div class="loading">Loading...</div>';
            tooltip.style.display = 'block';
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 10) + 'px';
            tooltip.classList.add('show');
            
            try {
                const definition = await getDefinition(word);
                tooltip.innerHTML = `<strong>${word}</strong>\n\n${definition}`;
            } catch (err) {
                tooltip.innerHTML = '‚ùå Could not load definition: ' + err.message;
            }
        }

        // UPDATED: Call Netlify Function instead of OpenAI directly
        async function getDefinition(word) {
            const response = await fetch('/.netlify/functions/openai-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    messages: [{
                        role: 'user',
                        content: `Berikan definisi singkat kata "${word}" dalam bahasa Indonesia:\n- Arti: [terjemahan]\n- Contoh: [kalimat bahasa Inggris]`
                    }],
                    max_tokens: 150
                })
            });

            if (!response.ok) {
                throw new Error('Failed to get definition');
            }

            const data = await response.json();
            return data.choices[0]?.message?.content || 'Unable to get definition';
        }

        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('word-highlight') && !tooltip.contains(e.target)) {
                tooltip.classList.remove('show');
            }
        });

        // UPDATED: Call Netlify Function for summary
        async function generateSummary() {
            if (!currentText) { showReadingError('No text to summarize'); return; }

            readingError.classList.remove('show');
            summaryBtn.disabled = true;
            readingResult.innerHTML = '<div class="loading">üìù Generating summary...</div>';
            readingResult.classList.add('show');

            try {
                const response = await fetch('/.netlify/functions/openai-proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: [{
                            role: 'user',
                            content: `Buatkan ringkasan dalam bahasa Indonesia:\n\n${currentText}`
                        }],
                        max_tokens: 500
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate summary');
                }

                const data = await response.json();
                readingResult.innerHTML = data.choices[0]?.message?.content || 'Unable to generate summary';
            } catch (err) {
                readingResult.classList.remove('show');
                showReadingError(err.message);
            } finally {
                summaryBtn.disabled = false;
            }
        }

        function showReadingError(message) {
            readingError.textContent = '‚ùå ' + message;
            readingError.classList.add('show');
        }
    </script>
</body>
</html>

